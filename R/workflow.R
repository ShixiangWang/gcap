#' GCAP workflow for gene-level amplicon prediction
#'
#' @inheritParams gcap.runASCAT
#' @inheritParams gcap.extractFeatures
#' @inheritParams gcap.collapse2Genes
#' @inheritParams gcap.runPrediction
#' @param target 'circle' and 'nonLinear' (not supported yet) to select model if predict circle
#' amplicon or non-linear amplicon. **Can be one or both**.
#' @param result_file_prefix file name prefix (without directory path) for storing
#' final model prediction file in CSV format.
#' Default a unique file name is generated by UUID approach.
#' @param extra_info (optional) a (file containing) `data.frame` with 3 columns 'sample'
#' (must identical to the setting of parameter `jobname`),
#' 'age' and 'gender'. For gender, should be 'XX' or 'XY',
#' also could be `0` for 'XX' and `1` for 'XY'.
#' @param skip_ascat_call if `TRUE`, skip calling ASCAT.
#' This is useful when you have done this step and just want
#' to run next steps.
#' @return a list of invisible `data.table` and corresponding files saved to local machine.
#' @export
gcap.workflow <- function(tumourseqfile, normalseqfile,
                          tumourname, normalname, jobname = tumourname,
                          extra_info = NULL,
                          include_type = FALSE,
                          genome_build = c("hg38", "hg19"),
                          model = "XGB32",
                          target = "circle",
                          outdir = getwd(),
                          result_file_prefix = paste0("gcap_", uuid::UUIDgenerate(TRUE)),
                          allelecounter_exe = "~/miniconda3/envs/cancerit/bin/alleleCounter",
                          g1000allelesprefix = file.path(
                            "~/data/snp/1000G_loci_hg38",
                            "1kg.phase3.v5a_GRCh38nounref_allele_index_chr"
                          ),
                          g1000lociprefix = file.path(
                            "~/data/snp/1000G_loci_hg38",
                            "1kg.phase3.v5a_GRCh38nounref_loci_chrstring_chr"
                          ),
                          GCcontentfile = "~/data/snp/GC_correction_hg38.txt",
                          replictimingfile = "~/data/snp/RT_correction_hg38.txt",
                          nthreads = 22,
                          minCounts = 10,
                          BED_file = NA,
                          probloci_file = NA,
                          chrom_names = 1:22,
                          min_base_qual = 20,
                          min_map_qual = 35,
                          penalty = 70,
                          skip_finished_ASCAT = TRUE,
                          skip_ascat_call = FALSE) {
  genome_build <- match.arg(genome_build)
  target <- match.arg(target, choices = c("circle", "nonLinear"), several.ok = TRUE)
  check_model(model)

  lg <- set_logger()
  lg$info("=====================")
  lg$info("   GCAP WORKFLOW")
  lg$info("=====================")
  lg$info()

  lg$info("=====================")
  lg$info("Step 1: Run ASCAT 3.0")
  lg$info("=====================")

  if (is.character(extra_info) && file.exists(extra_info)) {
    extra_info <- data.table::fread(extra_info, header = TRUE)
  }
  if (!is.null(extra_info)) {
    lg$info("Check extra_info values")
    if (!all(jobname %in% extra_info$sample)) {
      lg$warn("Cannot find all 'jobname' identifiers in 'sample' column of extra_info")
      lg$info("Try subsetting")
      extra_info <- extra_info[extra_info$sample %in% jobname, ]
      if (nrow(extra_info) == 0L) {
        lg$fatal("'sample' column is consistent with 'jobname', if no extra data, set it to NULL!")
        stop("Bad input")
      } else {
        if (nrow(extra_info) != length(jobname)) {
          lg$warn("Non-consistent sample records detected, try filling with default values")
          extra_info <- merge(
            data.table::data.table(sample = jobname),
            extra_info,
            by = "sample", all.x = TRUE
          )
          if (is.character(extra_info$gender)) {
            extra_info$gender <- data.table::fifelse(is.na(extra_info$gender), "XX", extra_info$gender, na = "XX")
          } else if (is.numeric(extra_info$gender)) {
            extra_info$gender <- data.table::fifelse(is.na(extra_info$gender), 0, extra_info$gender, na = 0)
          }
        }
      }
    } else {
      # Make sure the useful rows kept
      extra_info <- extra_info[extra_info$sample %in% jobname, ]
    }

    lg$info("Check sample order consistence in jobname and extra_info$sample")
    if (!all(jobname == extra_info$sample)) {
      lg$info("Sample order not consistent, try reordering")
      extra_info$sample <- factor(extra_info$sample, levels = jobname)
      extra_info <- extra_info[order(extra_info$sample), ]
      extra_info$sample <- as.character(extra_info$sample)
    }
  }
  totalT <- parallel::detectCores()
  if (nthreads > totalT) {
    lg$info("{nthreads} threads are set but only {totalT} cores are available, reset it to {totalT}")
    nthreads <- totalT
  }

  if (!skip_ascat_call) {
    gcap.runASCAT(
      tumourseqfile,
      normalseqfile,
      tumourname,
      normalname,
      jobname,
      outdir = outdir,
      allelecounter_exe = allelecounter_exe,
      g1000allelesprefix = g1000allelesprefix,
      g1000lociprefix = g1000lociprefix,
      GCcontentfile = GCcontentfile,
      replictimingfile = replictimingfile,
      nthreads = nthreads,
      minCounts = minCounts,
      BED_file = BED_file,
      probloci_file = probloci_file,
      chrom_names = chrom_names,
      gender = if (!is.null(extra_info)) {
        if (is.numeric(extra_info$gender)) {
          data.table::fifelse(extra_info$gender == 1, "XY", "XX", na = "XX")
        } else {
          extra_info$gender
        }
      } else {
        "XX"
      },
      min_base_qual = min_base_qual,
      min_map_qual = min_map_qual,
      penalty = penalty,
      skip_finished_ASCAT
    )
  }

  lg$info("checking ASCAT result files")
  ascat_files <- file.path(outdir, paste0(jobname, ".ASCAT.rds"))
  keep_idx <- sapply(ascat_files, function(x) {
    keep <- if (file.exists(x)) {
      file.info(x)$size > 2000
    } else {
      lg$warn("result file {x} does not exist, the corresponding ASCAT calling has error occurred ")
      FALSE
    }
    if (!keep) {
      lg$warn("{x} contains a failed ASCAT job, will discard it before next step")
    }
    keep
  })
  ascat_files <- ascat_files[keep_idx]
  if (length(ascat_files) < 1) {
    lg$fatal("no sucessful ASCAT result file to proceed!")
    lg$fatal("check your ASCAT setting before make sure this case could not be used!")
    stop()
  }

  lg$info("============================================================")
  lg$info("Step 2: Extract features and collapse features to gene level")
  lg$info("============================================================")

  model_input <- gcap.runBuildflow(
    ascat_files,
    extra_info,
    include_type = include_type,
    genome_build = genome_build
  )

  lg$info("=======================")
  lg$info("Step 3: Run prediction")
  lg$info("=======================")
  for (t in target) {
    model_input[[paste0("pred_", t)]] <- gcap.runPrediction(
      model_input,
      target = t,
      model = model
    )
  }
  model_input <- sortGeneDT(model_input)
  save_file <- file.path(outdir, paste0(result_file_prefix, "_by_gene.csv"))
  lg$info("Saving result to {save_file}")
  data.table::fwrite(model_input, file = save_file)

  lg$info("=======================")
  lg$info("Step 4: Run scoring")
  lg$info("=======================")
  out <- gcap.runScoring(model_input, genome_build)

  save_file <- file.path(outdir, paste0(result_file_prefix, "_by_case.csv"))
  lg$info("Saving result to {save_file}")
  data.table::fwrite(out, file = save_file)

  lg$info("=======================================")
  lg$info(" Done! Thanks for using GCAP workflow")
  lg$info("=======================================")

  invisible(list(
    by_gene = model_input,
    by_case = out
  ))
}
